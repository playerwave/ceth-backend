import { Repository } from "typeorm";
import { connectDatabase } from "../../db/database";
import { Activity } from "../../entity/Activity";
import logger from "../../middleware/logger";

export class ActivityDao {
  private activityRepository: Repository<Activity> | null = null;

  constructor() {
    this.initializeRepository();
  }

  // ‚úÖ ‡πÉ‡∏ä‡πâ async function ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
  private async initializeRepository(): Promise<void> {
    try {
      const connection = await connectDatabase();
      this.activityRepository = connection.getRepository(Activity);
      console.log("‚úÖ Activity Repository initialized");
    } catch (error) {
      console.error("‚ùå Error initializing ActivityDao(Admin):", error);
    }
  }

  private checkRepository(): void {
    if (!this.activityRepository) {
      throw new Error("Database connection is not established");
    }
  }

  async getAllActivitiesDao(userId: number): Promise<Activity[]> {
    this.checkRepository();

    try {
      logger.info(
        "üìå Fetching all public activities that user has not registered for"
      );

      // ‡∏î‡∏∂‡∏á‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà ac_status ‡πÄ‡∏õ‡πá‡∏ô 'public' ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ user ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô
      return await this.activityRepository!.createQueryBuilder("activity")
        .leftJoin("activity.userActivities", "user_activity") // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÇ‡∏¢‡∏á‡∏Å‡∏±‡∏ö user_activity
        .where("activity.ac_status = :status", { status: "Public" }) // ‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏Ñ‡πà public
        .andWhere(
          "user_activity.u_id IS NULL OR user_activity.u_id != :userId",
          { userId }
        ) // ‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏Ñ‡πà‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà userId ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô
        .getMany();
    } catch (error) {
      logger.error("‚ùå Error in getAllActivities(Admin):", error);
      throw new Error("Failed to get all activities");
    }
  }
}
